# Task 1.

Для обеспечения требуемой доступности и отказоустойчивости сервиса InureTech необходимо:

- использовать горизонтальное масштабирование и развернуть систему в нескольких зонах доступности;
- применить независимые кластеры Kubernetes в каждой зоне;
- реализовать глобальный и внутренние балансировщики нагрузки, включить механизмы health check;
- настроить кластер PostgreSQL с репликацией и регулярным резервным копированием;
- предусмотреть автоматическое переключение трафика между зонами при сбое (фейловер);
- на начальном этапе не использовать шардирование БД, но запланировать его возможность в будущем.

[InureTech_технологическая архитектура_to-be](task1/InureTech_технологическая%20архитектура_to-be.drawio)

# Task 2.

В рамках второго задания реализовано динамическое масштабирование контейнеров в Kubernetes:

- настроен Horizontal Pod Autoscaler (HPA) для управления количеством подов на основании утилизации памяти и количества запросов в секунду (RPS);
- установлен и настроен Prometheus для экспорта и мониторинга метрик приложения;
- предусмотрены механизмы нагрузочного тестирования с использованием Locust и других инструментов;
- реализована возможность масштабирования на основе кастомных метрик, включая RPS, время отклика и другие бизнес-метрики.


[Результат пункта 1](task2/subtask1-result)

[Результат пункта 2](task2/subtask2-result)


# Task 3.

Цель решения — повысить производительность и надёжность системы InsureTech, устранив текущие проблемы с взаимодействием сервисов и подготовив архитектуру к росту нагрузки после подключения дополнительных страховых компаний.

**Основные шаги решения:**

1. **Переход на асинхронный обмен данными (Event-Streaming):** 
    - для сервисов, которые сейчас используют синхронные REST API взаимодействия (например, core-app и ins-comp-settlement с ins-product-aggregator), предлагается перейти на асинхронный обмен через события;
    - использовать брокеры сообщений (Kafka или RabbitMQ) для передачи событий между сервисами;
    - это позволит снизить задержки и улучшить устойчивость системы, так как сервисы не будут блокироваться в ожидании ответа от других компонентов.
2. **Внедрение паттерна Transactional Outbox:**
    - сервисы, которые должны отправить сообщение или событие, сначала сохраняют его в базе данных как часть транзакции, в рамках которой они создают, удаляют или обновляют бизнес-сущность;
    - сообщение сохраняется в отдельную outbox-таблицу;
    - отдельный процесс вычитывает сообщения из outbox-таблицы и отправляет их через брокер сообщений;
    - это гарантирует, что даже при сбое в процессе отправки сообщения, данные не будут потеряны, а сообщения будут отправлены после устранения проблемы.
3. **Оптимизация взаимодействия сервисов:**
    - пересмотреть взаимодействия между core-app, ins-comp-settlement и ins-product-aggregator, чтобы определить, какие из них можно перевести на Event-Streaming;
    - оставить синхронные вызовы только там, где это абсолютно необходимо, а большую часть взаимодействий реализовать через асинхронные события.
4. **Обеспечение масштабируемости и отказоустойчивости:**
    - развернуть систему в нескольких зонах доступности, чтобы распределить нагрузку и обеспечить высокую доступность;
    - использовать кластер PostgreSQL с репликацией данных между зонами;
    - внедрить глобальный и внутренние балансировщики нагрузки для равномерного распределения трафика;
    - реализовать фейловер-стратегию для автоматического переключения трафика между зонами в случае сбоя.

**Ожидаемые результаты:**

- снижение задержек и ошибок взаимодействия между сервисами;
- повышение устойчивости системы к сбоям и росту нагрузки;
- улучшение времени отклика и общей производительности системы;
- готовность архитектуры к подключению дополнительных страховых компаний и увеличению объёма данных и запросов.


[InsureTech_C4_сontainer-diagram](task3/InsureTech_C4_сontainer-diagram.drawio.xml)


# Task 4.

1. **Реализация osago-aggregator:**
    - **Своё хранилище данных:** osago-aggregator будет использовать Redis в качестве кэша для хранения промежуточных данных и результатов запросов к страховым компаниям. Это позволит снизить нагрузку на основную базу данных и ускорить обработку запросов.
    - Данные, которые целесообразно хранить в Redis:
        - результаты отправки заявок в страховые компании;
        - промежуточные результаты обработки запросов;
        - часто используемые данные о тарифах и продуктах (для быстрого доступа).
2. **API, предоставляемый core-app:**
    - разработать REST API для обмена данными между osago-aggregator и core-app;
    - API должен включать следующие основные операции:
        - отправка заявок в страховые компании;
        - получение статусов обработки заявок;
        - получение информации о тарифах и продуктах.
3. **Средство интеграции между сервисами core-app и osago-aggregator:**
    - использовать REST API для интеграции;
    - для повышения производительности можно рассмотреть использование gRPC, особенно если требуется обмен большими объёмами данных или высокая пропускная способность.
4. **API для веб-приложения в core-app:**
    - реализовать GraphQL API, который позволит гибко запрашивать необходимые данные;
    - GraphQL позволит клиентам запрашивать только нужные данные, минимизируя объём передаваемой информации и улучшая производительность.
5. **Средство интеграции между веб-приложением и core-app:**
    - для интеграции между веб-приложением и core-app использовать GraphQL;
    - в случае необходимости высокой производительности и работы с бинарными данными можно рассмотреть использование gRPC.
6. **Применение паттернов отказоустойчивости:**
    - **Rate Limiting:** реализовать на уровне API для ограничения количества запросов от клиентов и предотвращения перегрузки системы;
    - **Circuit Breaker:** использовать для предотвращения дальнейших запросов к сервисам, которые временно недоступны, что снизит нагрузку на систему и ускорит обработку ошибок;
    - **Retry:** настроить механизм повторных попыток выполнения операций в случае временных сбоев;
    - **Timeout:** установить таймауты для операций, чтобы избежать бесконечного ожидания ответов от сервисов.
7. **Особенности работы с несколькими экземплярами сервисов:**
    - учитывая, что сервисы задеплоены в нескольких экземплярах, необходимо обеспечить согласованность данных в Redis;
    - для этого можно использовать Redis Cluster или другие механизмы репликации и синхронизации данных между узлами;
    - также важно настроить механизмы синхронизации кэша между экземплярами сервисов, чтобы избежать расхождений в данных.

[InsureTech_C4_сontainer-diagram](task4/InsureTech_C4_сontainer-diagram.drawio.xml)


# Task 5.

Для улучшения работы сервиса управления клиентскими данными (client-info) предлагается перейти на GraphQL API. Это позволит потребителям данных гибко выбирать необходимые данные клиента, избегая дублирования и избыточных запросов, и эффективно работать с объёмной карточкой клиента.

[client-inf.graphql](task5/client-inf.graphql)


# Task 6.


Для решения проблемы с производительностью API в InsureTech предлагается использовать паттерн Rate Limiting. Это позволит ограничить количество запросов от партнёров и предотвратить снижение производительности приложения, обеспечивая более равномерное распределение ресурсов и стабильность работы системы.

[nginx.conf](task5/nginx.conf)

